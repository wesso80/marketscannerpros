import { NextRequest, NextResponse } from 'next/server';
import { getSessionFromCookie } from '@/lib/auth';
import { q } from '@/lib/db';
import type { MSPEvent, WorkflowEventType } from '@/lib/workflow/types';

const ALLOWED_EVENT_TYPES = new Set<WorkflowEventType>([
  'operator.session.started',
  'operator.context.updated',
  'signal.created',
  'signal.updated',
  'candidate.created',
  'candidate.promoted',
  'candidate.evaluated',
  'trade.plan.created',
  'trade.plan.updated',
  'trade.executed',
  'trade.updated',
  'trade.closed',
  'journal.draft.created',
  'journal.updated',
  'journal.completed',
  'coach.analysis.generated',
  'strategy.rule.suggested',
  'strategy.rule.applied',
  'label.explicit.created',
  'trade.story.generated',
]);

function normalizeAlertAssetType(assetClass?: unknown): 'crypto' | 'equity' | 'forex' | 'commodity' {
  if (assetClass === 'crypto') return 'crypto';
  if (assetClass === 'forex') return 'forex';
  if (assetClass === 'commodities') return 'commodity';
  return 'equity';
}

function extractPlanAlertPrice(event: MSPEvent): number {
  const payload = event.payload as Record<string, any>;
  const entry = payload?.entry;

  const zone = entry?.zone;
  if (typeof zone === 'number' && Number.isFinite(zone)) return zone;

  if (typeof zone === 'string') {
    const parsed = Number(zone);
    if (Number.isFinite(parsed)) return parsed;
  }

  const low = entry?.low;
  const high = entry?.high;
  if (typeof low === 'number' && typeof high === 'number' && Number.isFinite(low) && Number.isFinite(high)) {
    return (low + high) / 2;
  }

  const currentPrice = entry?.current_price;
  if (typeof currentPrice === 'number' && Number.isFinite(currentPrice)) return currentPrice;

  return 0;
}

async function autoCreatePlanAlertForEvent(workspaceId: string, event: MSPEvent) {
  if (event.event_type !== 'trade.plan.created') return false;

  const payload = event.payload as Record<string, any>;
  const planId = String(payload?.plan_id || event.entity?.entity_id || '').trim();
  const symbol = String(payload?.symbol || event.entity?.symbol || '').trim().toUpperCase();
  if (!planId || !symbol) return false;

  const workflowId = event.correlation?.workflow_id;
  if (!workflowId) return false;

  const existing = await q(
    `SELECT id FROM alerts
     WHERE workspace_id = $1
       AND is_active = true
       AND is_smart_alert = true
       AND smart_alert_context->>'workflowId' = $2
       AND smart_alert_context->>'planId' = $3
     LIMIT 1`,
    [workspaceId, workflowId, planId]
  );

  if (existing.length > 0) return false;

  const alertPrice = extractPlanAlertPrice(event);
  const timeframe = typeof payload?.timeframe === 'string' ? payload.timeframe : null;
  const alertContext = {
    source: 'workflow.auto',
    autoGenerated: true,
    workflowId,
    parentEventId: event.event_id,
    planId,
    eventType: event.event_type,
  };

  await q(
    `INSERT INTO alerts (
      workspace_id, symbol, asset_type, condition_type, condition_value, condition_timeframe,
      name, notes, is_active, is_recurring, notify_email, notify_push,
      is_smart_alert, smart_alert_context, cooldown_minutes
    ) VALUES (
      $1, $2, $3, 'price_above', $4, $5,
      $6, $7, true, true, false, true,
      true, $8::jsonb, 60
    )`,
    [
      workspaceId,
      symbol,
      normalizeAlertAssetType(event.entity?.asset_class),
      alertPrice,
      timeframe,
      `MSP Auto Plan Alert â€¢ ${symbol}`,
      `Auto-generated from workflow plan ${planId}`,
      JSON.stringify(alertContext),
    ]
  );

  return true;
}

function isFiniteNumber(value: unknown): value is number {
  return typeof value === 'number' && Number.isFinite(value);
}

function validateCandidateCreatedEvent(event: MSPEvent): string | null {
  const payload = event.payload as Record<string, unknown>;
  if (!payload || typeof payload !== 'object') {
    return 'Invalid candidate.created payload';
  }

  const candidateId = payload.candidate_id;
  const signalId = payload.signal_id;
  const evaluatedAt = payload.evaluated_at;
  const result = payload.result;
  const finalConfidence = payload.final_confidence;
  const checks = payload.checks;
  const decisionPacket = payload.decision_packet as Record<string, unknown> | undefined;

  if (typeof candidateId !== 'string' || !candidateId.trim()) return 'candidate.created missing candidate_id';
  if (typeof signalId !== 'string' || !signalId.trim()) return 'candidate.created missing signal_id';
  if (typeof evaluatedAt !== 'string' || !evaluatedAt.trim()) return 'candidate.created missing evaluated_at';
  if (result !== 'pass' && result !== 'fail' && result !== 'watch') return 'candidate.created has invalid result';
  if (!isFiniteNumber(finalConfidence)) return 'candidate.created missing final_confidence';
  if (!Array.isArray(checks)) return 'candidate.created missing checks';
  if (!decisionPacket || typeof decisionPacket !== 'object') return 'candidate.created missing decision_packet';

  const packetId = decisionPacket.id;
  const packetSymbol = decisionPacket.symbol;
  const packetCreatedAt = decisionPacket.createdAt;
  const packetSignalSource = decisionPacket.signalSource;
  const packetSignalScore = decisionPacket.signalScore;
  const packetBias = decisionPacket.bias;
  const packetTimeframeBias = decisionPacket.timeframeBias;
  const packetRiskScore = decisionPacket.riskScore;
  const packetStatus = decisionPacket.status;

  if (typeof packetId !== 'string' || !packetId.trim()) return 'decision_packet missing id';
  if (typeof packetSymbol !== 'string' || !packetSymbol.trim()) return 'decision_packet missing symbol';
  if (typeof packetCreatedAt !== 'string' || !packetCreatedAt.trim()) return 'decision_packet missing createdAt';
  if (typeof packetSignalSource !== 'string' || !packetSignalSource.trim()) return 'decision_packet missing signalSource';
  if (!isFiniteNumber(packetSignalScore)) return 'decision_packet missing signalScore';
  if (packetBias !== 'bullish' && packetBias !== 'bearish' && packetBias !== 'neutral') return 'decision_packet has invalid bias';
  if (!Array.isArray(packetTimeframeBias)) return 'decision_packet missing timeframeBias';
  if (!isFiniteNumber(packetRiskScore)) return 'decision_packet missing riskScore';
  if (packetStatus !== 'candidate' && packetStatus !== 'planned' && packetStatus !== 'alerted' && packetStatus !== 'executed' && packetStatus !== 'closed') {
    return 'decision_packet has invalid status';
  }

  return null;
}

function normalizeEvent(raw: MSPEvent): MSPEvent {
  const nowIso = new Date().toISOString();

  return {
    ...raw,
    event_id: raw.event_id || `evt_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`,
    event_version: Number.isFinite(raw.event_version) ? raw.event_version : 1,
    occurred_at: raw.occurred_at || nowIso,
    actor: {
      actor_type: raw.actor?.actor_type || 'user',
      user_id: raw.actor?.user_id ?? null,
      anonymous_id: raw.actor?.anonymous_id ?? null,
      session_id: raw.actor?.session_id ?? null,
    },
    context: {
      tenant_id: raw.context?.tenant_id || 'msp',
      app: {
        name: raw.context?.app?.name || 'MarketScannerPros',
        env: raw.context?.app?.env || 'prod',
        build: raw.context?.app?.build,
      },
      page: raw.context?.page || {},
      device: raw.context?.device || {},
      geo: raw.context?.geo || {},
    },
    correlation: {
      workflow_id: raw.correlation?.workflow_id || `wf_${Date.now()}`,
      trace_id: raw.correlation?.trace_id,
      parent_event_id: raw.correlation?.parent_event_id ?? null,
    },
    payload: raw.payload || {},
  };
}

async function ensureJournalSchema() {
  await q(`
    CREATE TABLE IF NOT EXISTS journal_entries (
      id SERIAL PRIMARY KEY,
      workspace_id VARCHAR(100) NOT NULL,
      trade_date DATE NOT NULL,
      symbol VARCHAR(20) NOT NULL,
      side VARCHAR(10) NOT NULL CHECK (side IN ('LONG', 'SHORT')),
      trade_type VARCHAR(20) NOT NULL CHECK (trade_type IN ('Spot', 'Options', 'Futures', 'Margin')),
      option_type VARCHAR(10),
      strike_price DECIMAL(18, 8),
      expiration_date DATE,
      quantity DECIMAL(18, 8) NOT NULL,
      entry_price DECIMAL(18, 8) NOT NULL,
      exit_price DECIMAL(18, 8),
      exit_date DATE,
      pl DECIMAL(18, 8),
      pl_percent DECIMAL(10, 4),
      strategy VARCHAR(100),
      setup VARCHAR(100),
      notes TEXT,
      emotions TEXT,
      outcome VARCHAR(20) CHECK (outcome IN ('win', 'loss', 'breakeven', 'open')),
      tags TEXT[],
      is_open BOOLEAN DEFAULT TRUE,
      created_at TIMESTAMP DEFAULT NOW(),
      updated_at TIMESTAMP DEFAULT NOW()
    )
  `);

  await q(`CREATE INDEX IF NOT EXISTS idx_journal_entries_workspace ON journal_entries (workspace_id)`);
  await q(`CREATE INDEX IF NOT EXISTS idx_journal_entries_date ON journal_entries (workspace_id, trade_date DESC)`);

  await q(`ALTER TABLE journal_entries ADD COLUMN IF NOT EXISTS stop_loss DECIMAL(20,8)`);
  await q(`ALTER TABLE journal_entries ADD COLUMN IF NOT EXISTS target DECIMAL(20,8)`);
  await q(`ALTER TABLE journal_entries ADD COLUMN IF NOT EXISTS risk_amount DECIMAL(20,8)`);
  await q(`ALTER TABLE journal_entries ADD COLUMN IF NOT EXISTS r_multiple DECIMAL(10,4)`);
  await q(`ALTER TABLE journal_entries ADD COLUMN IF NOT EXISTS planned_rr DECIMAL(10,4)`);
}

async function autoCreateJournalDraftForEvent(workspaceId: string, event: MSPEvent) {
  if (event.event_type !== 'trade.plan.created') return false;

  const payload = event.payload as Record<string, any>;
  const planId = String(payload?.plan_id || event.entity?.entity_id || '').trim();
  const symbol = String(payload?.symbol || event.entity?.symbol || '').trim().toUpperCase();
  if (!planId || !symbol) return false;

  const workflowId = event.correlation?.workflow_id;
  if (!workflowId) return false;

  await ensureJournalSchema();

  const planTag = `plan_${planId}`;
  const dedupe = await q(
    `SELECT id FROM journal_entries
     WHERE workspace_id = $1
       AND symbol = $2
       AND is_open = true
       AND outcome = 'open'
       AND (
         COALESCE(tags, ARRAY[]::text[]) @> ARRAY[$3]::text[]
         OR notes ILIKE $4
       )
     LIMIT 1`,
    [workspaceId, symbol, planTag, `%${planId}%`]
  );

  if (dedupe.length > 0) return false;

  const direction = String(payload?.direction || '').toLowerCase();
  const side = direction === 'short' ? 'SHORT' : 'LONG';
  const tradeDate = new Date().toISOString().slice(0, 10);
  const entryPrice = extractPlanAlertPrice(event);

  const setupSource = String(payload?.setup?.source || payload?.setup?.signal_type || 'scanner.plan').slice(0, 100);
  const strategy = String(payload?.setup?.signal_type || 'confluence_scan').slice(0, 100);
  const notes = [
    'Auto-created from trade plan event.',
    `Workflow: ${workflowId}`,
    `Plan: ${planId}`,
    `Source: ${setupSource}`,
    `Direction: ${direction || 'neutral'}`,
    `Risk Score: ${payload?.risk?.risk_score ?? 'n/a'}`,
  ].join('\n');

  await q(
    `INSERT INTO journal_entries (
      workspace_id, trade_date, symbol, side, trade_type, quantity, entry_price,
      strategy, setup, notes, emotions, outcome, tags, is_open
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7,
      $8, $9, $10, $11, $12, $13, $14
    )`,
    [
      workspaceId,
      tradeDate,
      symbol,
      side,
      'Spot',
      1,
      entryPrice,
      strategy,
      setupSource,
      notes,
      '',
      'open',
      ['auto_plan_draft', `workflow_${workflowId}`, planTag],
      true,
    ]
  );

  return true;
}

export async function POST(req: NextRequest) {
  try {
    const session = await getSessionFromCookie();
    if (!session?.workspaceId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();
    const events = Array.isArray(body?.events) ? (body.events as MSPEvent[]) : [];

    if (!events.length) {
      return NextResponse.json({ error: 'No events provided' }, { status: 400 });
    }

    const normalized = events.slice(0, 100).map(normalizeEvent);

    for (const event of normalized) {
      if (!ALLOWED_EVENT_TYPES.has(event.event_type)) {
        return NextResponse.json({ error: `Unsupported event type: ${event.event_type}` }, { status: 400 });
      }
      if (!event.event_id || !event.correlation?.workflow_id) {
        return NextResponse.json({ error: 'Invalid envelope: missing event_id/workflow_id' }, { status: 400 });
      }

      if (event.event_type === 'candidate.created') {
        const candidateError = validateCandidateCreatedEvent(event);
        if (candidateError) {
          return NextResponse.json({ error: candidateError }, { status: 400 });
        }
      }
    }

    let autoAlertsCreated = 0;
    let autoJournalDraftsCreated = 0;
    for (const event of normalized) {
      if (await autoCreatePlanAlertForEvent(session.workspaceId, event)) {
        autoAlertsCreated += 1;
      }
      if (await autoCreateJournalDraftForEvent(session.workspaceId, event)) {
        autoJournalDraftsCreated += 1;
      }
    }

    const values: unknown[] = [];
    const placeholders: string[] = [];
    let index = 1;

    for (const event of normalized) {
      placeholders.push(`($${index}, $${index + 1}, $${index + 2}::jsonb, $${index + 3}::jsonb, $${index + 4})`);
      values.push(
        session.workspaceId,
        event.event_type,
        JSON.stringify(event),
        JSON.stringify(event.context?.page || {}),
        event.actor?.session_id || null
      );
      index += 5;
    }

    await q(
      `INSERT INTO ai_events (workspace_id, event_type, event_data, page_context, session_id)
       VALUES ${placeholders.join(', ')}`,
      values
    );

    return NextResponse.json({
      success: true,
      eventsLogged: normalized.length,
      autoAlertsCreated,
      autoJournalDraftsCreated,
    });
  } catch (error) {
    console.error('Workflow events API error:', error);
    return NextResponse.json({ error: 'Failed to ingest workflow events' }, { status: 500 });
  }
}
