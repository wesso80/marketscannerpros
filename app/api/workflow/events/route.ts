import { NextRequest, NextResponse } from 'next/server';
import { getSessionFromCookie } from '@/lib/auth';
import { q } from '@/lib/db';
import type { MSPEvent, WorkflowEventType } from '@/lib/workflow/types';

const ALLOWED_EVENT_TYPES = new Set<WorkflowEventType>([
  'operator.session.started',
  'operator.context.updated',
  'signal.created',
  'signal.updated',
  'candidate.created',
  'candidate.promoted',
  'candidate.evaluated',
  'trade.plan.created',
  'trade.plan.updated',
  'trade.executed',
  'trade.updated',
  'trade.closed',
  'journal.draft.created',
  'journal.updated',
  'journal.completed',
  'coach.analysis.generated',
  'strategy.rule.suggested',
  'strategy.rule.applied',
  'label.explicit.created',
  'trade.story.generated',
]);

function normalizeAlertAssetType(assetClass?: unknown): 'crypto' | 'equity' | 'forex' | 'commodity' {
  if (assetClass === 'crypto') return 'crypto';
  if (assetClass === 'forex') return 'forex';
  if (assetClass === 'commodities') return 'commodity';
  return 'equity';
}

function extractPlanAlertPrice(event: MSPEvent): number {
  const payload = event.payload as Record<string, any>;
  const entry = payload?.entry;

  const zone = entry?.zone;
  if (typeof zone === 'number' && Number.isFinite(zone)) return zone;

  if (typeof zone === 'string') {
    const parsed = Number(zone);
    if (Number.isFinite(parsed)) return parsed;
  }

  const low = entry?.low;
  const high = entry?.high;
  if (typeof low === 'number' && typeof high === 'number' && Number.isFinite(low) && Number.isFinite(high)) {
    return (low + high) / 2;
  }

  const currentPrice = entry?.current_price;
  if (typeof currentPrice === 'number' && Number.isFinite(currentPrice)) return currentPrice;

  return 0;
}

async function autoCreatePlanAlertForEvent(workspaceId: string, event: MSPEvent) {
  if (event.event_type !== 'trade.plan.created') return false;

  const payload = event.payload as Record<string, any>;
  const planId = String(payload?.plan_id || event.entity?.entity_id || '').trim();
  const symbol = String(payload?.symbol || event.entity?.symbol || '').trim().toUpperCase();
  if (!planId || !symbol) return false;

  const workflowId = event.correlation?.workflow_id;
  if (!workflowId) return false;

  const existing = await q(
    `SELECT id FROM alerts
     WHERE workspace_id = $1
       AND is_active = true
       AND is_smart_alert = true
       AND smart_alert_context->>'workflowId' = $2
       AND smart_alert_context->>'planId' = $3
     LIMIT 1`,
    [workspaceId, workflowId, planId]
  );

  if (existing.length > 0) return false;

  const alertPrice = extractPlanAlertPrice(event);
  const timeframe = typeof payload?.timeframe === 'string' ? payload.timeframe : null;
  const alertContext = {
    source: 'workflow.auto',
    autoGenerated: true,
    workflowId,
    parentEventId: event.event_id,
    planId,
    eventType: event.event_type,
  };

  await q(
    `INSERT INTO alerts (
      workspace_id, symbol, asset_type, condition_type, condition_value, condition_timeframe,
      name, notes, is_active, is_recurring, notify_email, notify_push,
      is_smart_alert, smart_alert_context, cooldown_minutes
    ) VALUES (
      $1, $2, $3, 'price_above', $4, $5,
      $6, $7, true, true, false, true,
      true, $8::jsonb, 60
    )`,
    [
      workspaceId,
      symbol,
      normalizeAlertAssetType(event.entity?.asset_class),
      alertPrice,
      timeframe,
      `MSP Auto Plan Alert • ${symbol}`,
      `Auto-generated from workflow plan ${planId}`,
      JSON.stringify(alertContext),
    ]
  );

  return true;
}

function isFiniteNumber(value: unknown): value is number {
  return typeof value === 'number' && Number.isFinite(value);
}

function validateCandidateCreatedEvent(event: MSPEvent): string | null {
  const payload = event.payload as Record<string, unknown>;
  if (!payload || typeof payload !== 'object') {
    return 'Invalid candidate.created payload';
  }

  const candidateId = payload.candidate_id;
  const signalId = payload.signal_id;
  const evaluatedAt = payload.evaluated_at;
  const result = payload.result;
  const finalConfidence = payload.final_confidence;
  const checks = payload.checks;
  const decisionPacket = payload.decision_packet as Record<string, unknown> | undefined;

  if (typeof candidateId !== 'string' || !candidateId.trim()) return 'candidate.created missing candidate_id';
  if (typeof signalId !== 'string' || !signalId.trim()) return 'candidate.created missing signal_id';
  if (typeof evaluatedAt !== 'string' || !evaluatedAt.trim()) return 'candidate.created missing evaluated_at';
  if (result !== 'pass' && result !== 'fail' && result !== 'watch') return 'candidate.created has invalid result';
  if (!isFiniteNumber(finalConfidence)) return 'candidate.created missing final_confidence';
  if (!Array.isArray(checks)) return 'candidate.created missing checks';
  if (!decisionPacket || typeof decisionPacket !== 'object') return 'candidate.created missing decision_packet';

  const packetId = decisionPacket.id;
  const packetSymbol = decisionPacket.symbol;
  const packetCreatedAt = decisionPacket.createdAt;
  const packetSignalSource = decisionPacket.signalSource;
  const packetSignalScore = decisionPacket.signalScore;
  const packetBias = decisionPacket.bias;
  const packetTimeframeBias = decisionPacket.timeframeBias;
  const packetRiskScore = decisionPacket.riskScore;
  const packetStatus = decisionPacket.status;

  if (typeof packetId !== 'string' || !packetId.trim()) return 'decision_packet missing id';
  if (typeof packetSymbol !== 'string' || !packetSymbol.trim()) return 'decision_packet missing symbol';
  if (typeof packetCreatedAt !== 'string' || !packetCreatedAt.trim()) return 'decision_packet missing createdAt';
  if (typeof packetSignalSource !== 'string' || !packetSignalSource.trim()) return 'decision_packet missing signalSource';
  if (!isFiniteNumber(packetSignalScore)) return 'decision_packet missing signalScore';
  if (packetBias !== 'bullish' && packetBias !== 'bearish' && packetBias !== 'neutral') return 'decision_packet has invalid bias';
  if (!Array.isArray(packetTimeframeBias)) return 'decision_packet missing timeframeBias';
  if (!isFiniteNumber(packetRiskScore)) return 'decision_packet missing riskScore';
  if (packetStatus !== 'candidate' && packetStatus !== 'planned' && packetStatus !== 'alerted' && packetStatus !== 'executed' && packetStatus !== 'closed') {
    return 'decision_packet has invalid status';
  }

  return null;
}

function normalizeEvent(raw: MSPEvent): MSPEvent {
  const nowIso = new Date().toISOString();

  return {
    ...raw,
    event_id: raw.event_id || `evt_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`,
    event_version: Number.isFinite(raw.event_version) ? raw.event_version : 1,
    occurred_at: raw.occurred_at || nowIso,
    actor: {
      actor_type: raw.actor?.actor_type || 'user',
      user_id: raw.actor?.user_id ?? null,
      anonymous_id: raw.actor?.anonymous_id ?? null,
      session_id: raw.actor?.session_id ?? null,
    },
    context: {
      tenant_id: raw.context?.tenant_id || 'msp',
      app: {
        name: raw.context?.app?.name || 'MarketScannerPros',
        env: raw.context?.app?.env || 'prod',
        build: raw.context?.app?.build,
      },
      page: raw.context?.page || {},
      device: raw.context?.device || {},
      geo: raw.context?.geo || {},
    },
    correlation: {
      workflow_id: raw.correlation?.workflow_id || `wf_${Date.now()}`,
      trace_id: raw.correlation?.trace_id,
      parent_event_id: raw.correlation?.parent_event_id ?? null,
    },
    payload: raw.payload || {},
  };
}

async function ensureJournalSchema() {
  await q(`
    CREATE TABLE IF NOT EXISTS journal_entries (
      id SERIAL PRIMARY KEY,
      workspace_id VARCHAR(100) NOT NULL,
      trade_date DATE NOT NULL,
      symbol VARCHAR(20) NOT NULL,
      side VARCHAR(10) NOT NULL CHECK (side IN ('LONG', 'SHORT')),
      trade_type VARCHAR(20) NOT NULL CHECK (trade_type IN ('Spot', 'Options', 'Futures', 'Margin')),
      option_type VARCHAR(10),
      strike_price DECIMAL(18, 8),
      expiration_date DATE,
      quantity DECIMAL(18, 8) NOT NULL,
      entry_price DECIMAL(18, 8) NOT NULL,
      exit_price DECIMAL(18, 8),
      exit_date DATE,
      pl DECIMAL(18, 8),
      pl_percent DECIMAL(10, 4),
      strategy VARCHAR(100),
      setup VARCHAR(100),
      notes TEXT,
      emotions TEXT,
      outcome VARCHAR(20) CHECK (outcome IN ('win', 'loss', 'breakeven', 'open')),
      tags TEXT[],
      is_open BOOLEAN DEFAULT TRUE,
      created_at TIMESTAMP DEFAULT NOW(),
      updated_at TIMESTAMP DEFAULT NOW()
    )
  `);

  await q(`CREATE INDEX IF NOT EXISTS idx_journal_entries_workspace ON journal_entries (workspace_id)`);
  await q(`CREATE INDEX IF NOT EXISTS idx_journal_entries_date ON journal_entries (workspace_id, trade_date DESC)`);

  await q(`ALTER TABLE journal_entries ADD COLUMN IF NOT EXISTS stop_loss DECIMAL(20,8)`);
  await q(`ALTER TABLE journal_entries ADD COLUMN IF NOT EXISTS target DECIMAL(20,8)`);
  await q(`ALTER TABLE journal_entries ADD COLUMN IF NOT EXISTS risk_amount DECIMAL(20,8)`);
  await q(`ALTER TABLE journal_entries ADD COLUMN IF NOT EXISTS r_multiple DECIMAL(10,4)`);
  await q(`ALTER TABLE journal_entries ADD COLUMN IF NOT EXISTS planned_rr DECIMAL(10,4)`);
}

async function autoCreateJournalDraftForEvent(workspaceId: string, event: MSPEvent) {
  if (event.event_type !== 'trade.plan.created') return false;

  const payload = event.payload as Record<string, any>;
  const planId = String(payload?.plan_id || event.entity?.entity_id || '').trim();
  const symbol = String(payload?.symbol || event.entity?.symbol || '').trim().toUpperCase();
  if (!planId || !symbol) return false;

  const workflowId = event.correlation?.workflow_id;
  if (!workflowId) return false;

  await ensureJournalSchema();

  const planTag = `plan_${planId}`;
  const dedupe = await q(
    `SELECT id FROM journal_entries
     WHERE workspace_id = $1
       AND symbol = $2
       AND is_open = true
       AND outcome = 'open'
       AND (
         COALESCE(tags, ARRAY[]::text[]) @> ARRAY[$3]::text[]
         OR notes ILIKE $4
       )
     LIMIT 1`,
    [workspaceId, symbol, planTag, `%${planId}%`]
  );

  if (dedupe.length > 0) return false;

  const direction = String(payload?.direction || '').toLowerCase();
  const side = direction === 'short' ? 'SHORT' : 'LONG';
  const tradeDate = new Date().toISOString().slice(0, 10);
  const entryPrice = extractPlanAlertPrice(event);

  const setupSource = String(payload?.setup?.source || payload?.setup?.signal_type || 'scanner.plan').slice(0, 100);
  const strategy = String(payload?.setup?.signal_type || 'confluence_scan').slice(0, 100);
  const notes = [
    'Auto-created from trade plan event.',
    `Workflow: ${workflowId}`,
    `Plan: ${planId}`,
    `Source: ${setupSource}`,
    `Direction: ${direction || 'neutral'}`,
    `Risk Score: ${payload?.risk?.risk_score ?? 'n/a'}`,
  ].join('\n');

  await q(
    `INSERT INTO journal_entries (
      workspace_id, trade_date, symbol, side, trade_type, quantity, entry_price,
      strategy, setup, notes, emotions, outcome, tags, is_open
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7,
      $8, $9, $10, $11, $12, $13, $14
    )`,
    [
      workspaceId,
      tradeDate,
      symbol,
      side,
      'Spot',
      1,
      entryPrice,
      strategy,
      setupSource,
      notes,
      '',
      'open',
      ['auto_plan_draft', `workflow_${workflowId}`, planTag],
      true,
    ]
  );

  return true;
}

function buildCoachRecommendations(args: {
  winRate: number;
  avgWin: number;
  avgLoss: number;
  expectancy: number;
  sampleSize: number;
}): Array<Record<string, unknown>> {
  const recommendations: Array<Record<string, unknown>> = [];

  if (args.sampleSize < 5) {
    recommendations.push({
      priority: 'high',
      action: 'increase_sample_size',
      detail: 'Collect at least 5-10 closed trades before adjusting strategy parameters.',
    });
  }

  if (args.avgLoss > 0 && args.avgWin > 0 && args.avgWin < args.avgLoss) {
    recommendations.push({
      priority: 'high',
      action: 'improve_reward_to_risk',
      detail: 'Average loss is larger than average win. Tighten invalidation or extend target structure.',
    });
  }

  if (args.winRate < 45) {
    recommendations.push({
      priority: 'medium',
      action: 'tighten_entry_filter',
      detail: 'Win rate is below 45%. Increase selectivity on setup quality before execution.',
    });
  }

  if (args.expectancy > 0) {
    recommendations.push({
      priority: 'medium',
      action: 'keep_size_consistent',
      detail: 'Expectancy is positive. Keep sizing stable and avoid emotional scaling.',
    });
  }

  if (!recommendations.length) {
    recommendations.push({
      priority: 'medium',
      action: 'continue_process_discipline',
      detail: 'Maintain process consistency and review another batch after additional closures.',
    });
  }

  return recommendations;
}

async function autoGenerateCoachEventForClosedTrade(workspaceId: string, event: MSPEvent): Promise<MSPEvent | null> {
  if (event.event_type !== 'trade.closed') return null;

  const workflowId = event.correlation?.workflow_id;
  if (!workflowId) return null;

  const alreadyGenerated = await q(
    `SELECT id FROM ai_events
     WHERE workspace_id = $1
       AND event_type = 'coach.analysis.generated'
       AND event_data->'correlation'->>'parent_event_id' = $2
     LIMIT 1`,
    [workspaceId, event.event_id]
  );

  if (alreadyGenerated.length > 0) return null;

  const recentClosed = await q(
    `SELECT pl, outcome
     FROM journal_entries
     WHERE workspace_id = $1
       AND is_open = false
     ORDER BY COALESCE(exit_date, trade_date) DESC NULLS LAST
     LIMIT 20`,
    [workspaceId]
  );

  const sampleSize = recentClosed.length;
  const wins = recentClosed.filter((row: any) => Number(row.pl || 0) > 0 || row.outcome === 'win');
  const losses = recentClosed.filter((row: any) => Number(row.pl || 0) < 0 || row.outcome === 'loss');
  const winRate = sampleSize > 0 ? (wins.length / sampleSize) * 100 : 0;
  const avgWin = wins.length > 0
    ? wins.reduce((sum: number, row: any) => sum + Math.max(0, Number(row.pl || 0)), 0) / wins.length
    : 0;
  const avgLoss = losses.length > 0
    ? Math.abs(losses.reduce((sum: number, row: any) => sum + Math.min(0, Number(row.pl || 0)), 0) / losses.length)
    : 0;
  const expectancy = (winRate / 100) * avgWin - (1 - winRate / 100) * avgLoss;

  const payload = event.payload as Record<string, any>;
  const tradeId = String(payload?.trade_id || event.entity?.entity_id || '').trim();
  const analysisId = `coach_${tradeId || Date.now()}`;

  return normalizeEvent({
    event_id: `evt_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`,
    event_type: 'coach.analysis.generated',
    event_version: 1,
    occurred_at: new Date().toISOString(),
    actor: {
      actor_type: 'system',
      user_id: null,
      anonymous_id: null,
      session_id: null,
    },
    context: {
      tenant_id: event.context?.tenant_id || 'msp',
      app: {
        name: event.context?.app?.name || 'MarketScannerPros',
        env: event.context?.app?.env || 'prod',
        build: event.context?.app?.build,
      },
      page: {
        route: '/tools/journal',
        module: 'coach_engine',
      },
      device: {},
      geo: {},
    },
    entity: {
      entity_type: 'coach',
      entity_id: analysisId,
      symbol: event.entity?.symbol,
      asset_class: event.entity?.asset_class,
    },
    correlation: {
      workflow_id: workflowId,
      parent_event_id: event.event_id,
    },
    payload: {
      analysis_id: analysisId,
      created_at: new Date().toISOString(),
      scope: 'post_trade_close',
      inputs: {
        trade_id: tradeId || null,
        source_event_id: event.event_id,
      },
      summary: {
        sample_size: sampleSize,
        win_rate: Number(winRate.toFixed(2)),
        avg_win: Number(avgWin.toFixed(2)),
        avg_loss: Number(avgLoss.toFixed(2)),
        expectancy: Number(expectancy.toFixed(2)),
      },
      recommendations: buildCoachRecommendations({
        winRate,
        avgWin,
        avgLoss,
        expectancy,
        sampleSize,
      }),
      links: {
        trade_id: tradeId || null,
      },
    },
  });
}

async function attachCoachSummaryToJournalDraft(workspaceId: string, coachEvent: MSPEvent): Promise<boolean> {
  if (coachEvent.event_type !== 'coach.analysis.generated') return false;

  const workflowId = coachEvent.correlation?.workflow_id;
  if (!workflowId) return false;

  const payload = coachEvent.payload as Record<string, any>;
  const analysisId = String(payload?.analysis_id || '').trim();
  if (!analysisId) return false;

  const workflowTag = `workflow_${workflowId}`;
  const draftRows = await q(
    `SELECT id, notes
     FROM journal_entries
     WHERE workspace_id = $1
       AND is_open = true
       AND outcome = 'open'
       AND COALESCE(tags, ARRAY[]::text[]) @> ARRAY[$2]::text[]
     ORDER BY created_at DESC
     LIMIT 1`,
    [workspaceId, workflowTag]
  );

  if (draftRows.length === 0) return false;

  const draft = draftRows[0] as { id: number; notes?: string | null };
  const existingNotes = String(draft.notes || '');
  if (existingNotes.includes(`Coach Analysis ID: ${analysisId}`)) {
    return false;
  }

  const summary = payload?.summary as Record<string, any> | undefined;
  const recommendations = Array.isArray(payload?.recommendations)
    ? (payload.recommendations as Array<Record<string, any>>)
    : [];

  const lines = [
    '',
    '---',
    'AI Coach Auto-Analysis',
    `Coach Analysis ID: ${analysisId}`,
    `Win Rate: ${summary?.win_rate ?? 'n/a'}%`,
    `Avg Win: ${summary?.avg_win ?? 'n/a'}`,
    `Avg Loss: ${summary?.avg_loss ?? 'n/a'}`,
    `Expectancy: ${summary?.expectancy ?? 'n/a'}`,
    ...recommendations.slice(0, 3).map((item, idx) => {
      const action = String(item?.action || 'action');
      const detail = String(item?.detail || '');
      return `Recommendation ${idx + 1}: ${action}${detail ? ` — ${detail}` : ''}`;
    }),
  ];

  const mergedNotes = `${existingNotes}${lines.join('\n')}`.trim();

  await q(
    `UPDATE journal_entries
     SET notes = $2,
         updated_at = NOW()
     WHERE id = $1`,
    [draft.id, mergedNotes]
  );

  return true;
}

export async function POST(req: NextRequest) {
  try {
    const session = await getSessionFromCookie();
    if (!session?.workspaceId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();
    const events = Array.isArray(body?.events) ? (body.events as MSPEvent[]) : [];

    if (!events.length) {
      return NextResponse.json({ error: 'No events provided' }, { status: 400 });
    }

    const normalized = events.slice(0, 100).map(normalizeEvent);

    for (const event of normalized) {
      if (!ALLOWED_EVENT_TYPES.has(event.event_type)) {
        return NextResponse.json({ error: `Unsupported event type: ${event.event_type}` }, { status: 400 });
      }
      if (!event.event_id || !event.correlation?.workflow_id) {
        return NextResponse.json({ error: 'Invalid envelope: missing event_id/workflow_id' }, { status: 400 });
      }

      if (event.event_type === 'candidate.created') {
        const candidateError = validateCandidateCreatedEvent(event);
        if (candidateError) {
          return NextResponse.json({ error: candidateError }, { status: 400 });
        }
      }
    }

    let autoAlertsCreated = 0;
    let autoJournalDraftsCreated = 0;
    let autoCoachJournalUpdates = 0;
    const autoCoachEvents: MSPEvent[] = [];
    for (const event of normalized) {
      if (await autoCreatePlanAlertForEvent(session.workspaceId, event)) {
        autoAlertsCreated += 1;
      }
      if (await autoCreateJournalDraftForEvent(session.workspaceId, event)) {
        autoJournalDraftsCreated += 1;
      }

      const coachEvent = await autoGenerateCoachEventForClosedTrade(session.workspaceId, event);
      if (coachEvent) {
        autoCoachEvents.push(coachEvent);
        if (await attachCoachSummaryToJournalDraft(session.workspaceId, coachEvent)) {
          autoCoachJournalUpdates += 1;
        }
      }
    }

    const eventsToPersist = [...normalized, ...autoCoachEvents];

    const values: unknown[] = [];
    const placeholders: string[] = [];
    let index = 1;

    for (const event of eventsToPersist) {
      placeholders.push(`($${index}, $${index + 1}, $${index + 2}::jsonb, $${index + 3}::jsonb, $${index + 4})`);
      values.push(
        session.workspaceId,
        event.event_type,
        JSON.stringify(event),
        JSON.stringify(event.context?.page || {}),
        event.actor?.session_id || null
      );
      index += 5;
    }

    await q(
      `INSERT INTO ai_events (workspace_id, event_type, event_data, page_context, session_id)
       VALUES ${placeholders.join(', ')}`,
      values
    );

    return NextResponse.json({
      success: true,
      eventsLogged: eventsToPersist.length,
      sourceEventsLogged: normalized.length,
      autoAlertsCreated,
      autoJournalDraftsCreated,
      autoCoachAnalysesGenerated: autoCoachEvents.length,
      autoCoachJournalUpdates,
    });
  } catch (error) {
    console.error('Workflow events API error:', error);
    return NextResponse.json({ error: 'Failed to ingest workflow events' }, { status: 500 });
  }
}
